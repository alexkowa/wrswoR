---
author:
  - name: Kirill Müller
    affiliation: IVT, ETH Zurich
    address: >
      Stefano-Franscini-Platz 9
      8093 Zürich
    email: kirill.mueller@ivt.baug.ethz.ch
    url: http://www.ivt.ethz.ch
title:
  formatted: "Accelerating weighted random sampling without replacement"
  # If you use tex in the formatted title, also supply version without
  plain:     "Accelerating weighted random sampling without replacement"
  # For running headers, if needed
  short:     "Accelerating weighted random sampling without replacement"
abstract: >
  The abstract of the article.
keywords:
  # at least one keyword must be supplied
  formatted: [keywords, not capitalized, "\\proglang{R}"]
  plain:     [keywords, not capitalized, R]
preamble: >
  \usepackage{amsmath}
  \usepackage[USenglish]{babel}
  \usepackage{algorithm}
  \usepackage{algorithmic}
  \usepackage[draft]{fixme}
  \usepackage[capitalize]{cleveref}
output: rticles::jss_article
---

# Introduction

Random sampling is one of the basic primitives in statistical computing.
\fxwarning{Used where?}

This paper focuses on a specific variant: sampling without replacement from a finite population
with non-uniform probability distribution.
\fxwarning{Application?}

First, different techniques for sampling from discrete populations are reviewed.
Several implementations for sampling without replacement are discussed,
this includes evaluation of correctness and runtime performance.
The paper concludes with suggestions for incorporating the findings into base
\proglang{R}.


# Sampling from discrete populations

We use \cref{alg:sample} as a definition of sampling from discrete populations
with or without replacement from arbitrary (including uniform) probability distributions.
From this definition, the following can be observed:

\begin{algorithm}
  \caption{$\text{sample}(n, s, \text{replace}, p_i)$}
  \label{alg:sample}
  \begin{algorithmic}[1]
    \REQUIRE $n$: Size of the population
    \REQUIRE $s$: Number of items to sample
    \REQUIRE $\text{replace}$: \TRUE{} to request sampling with replacement
    \REQUIRE $p_i$: Relative probability of each item for $i \in \{1,\ldots,n\}$
    \ENSURE Returns a vector $k_j \in \{1,\ldots,n\} $ with
      $j \in \{1,\ldots,s\}$ that contains the indexes of the items sampled
    \IF{$s = 0$}
      \RETURN vector of length 0
    \ENDIF
    \STATE Randomly select $k$ so that $\mathrm{P}(k=i) = \frac{p_k}{\sum_{j}p_j}$
      for all $i$ \label{alg:sample:norm}
    \IF{not replace}\label{alg:sample:if}
      \STATE $n \leftarrow n - 1$
      \STATE remove item $k$ from $p_i$\label{alg:sample:remove}
    \ENDIF
    \RETURN $k \oplus \text{sample}(n, s - 1, \text{replace}, p_i)$
  \end{algorithmic}
\end{algorithm}

- Sampling with replacement appears to be a simpler problem than sampling without
  replacement, as the block starting at line \ref{alg:sample:if} is not required.
- If all probabilities $p_i$ are equal, the selection probability $\mathrm{P}(i=k)$
  of the sampled items in line \ref{alg:sample:norm} always equals $\frac{1}{n}$
  and does not have to be computed explicitly.

In this framework, sampling without replacement with non-uniform probabilities
is the hardest problem.
This intuition carries over to the more specialized algorithms that implement
each case.


## With replacement

The *with replacement* case corresponds to repeated selection of $k$ from *the same*
discrete probability distribution.
The uniform case can be implemented easily by scaling and discretizing the
output of a random number generator.
More work is needed in the non-uniform case.
Assuming w.l.o.g.\ $\sum_j p_j = n$,
it is possible to construct (in $O(n)$ time) a subdivision
$(l_i, r_i, s_i)$ with $i, l_i, r_i \in \{1,\ldots,n\}$
and $0 < s_i \leq 1$ so that $$p_i = \sum_{j:l_j=i}{s_j} + \sum_{j:r_j=i}{(1-s_j)}$$
\fxwarning{Cite Walker's alias method}.
Choosing an item requires sampling from $\{1,\ldots,n\}$ (to choose $i$) 
and then sampling from $\left[0, 1\right)$ (to choose $l_i$ or $r_i$).
(Figuratively, the probability mass given by $p_i$
is distributed over $n$ "boxes" so that the space in each box $i$
is assigned to at most two items
$l_i$ and $r_i$.
The share occupied by item $l_i$ in box $i$ is given by $s_i$.
Each item can be distributed over several boxes.  
Choosing an items means selecting a box and choosing between the two items in this box.)

The preprocessing time of $O(n)$ required for Walker's alias method
is also the lower bound for arbitrary probability distributions.
It is easy to see that the entire probability vector must be read at least once.
Hence, for nonuniform probabilities,
the run time is at least $O(n + s)$, and the input size $n$ will dominate
unless $s \ge O(n)$.


## Without replacement

In the *without replacement* case, each selected item is removed from the
collection of candidate items.
Again, the uniform case is much simpler.
An unordered array of size $n$, initialized with the natural sequence,
can be used for storing the candidate items.
The selection of the item corresponds to choosing an index at random in this
unordered array.
Removal of an item with known index can be done in $O(1)$ time.
\fxwarning{Reservoir for $s \ll n$}
For the non-uniform case,
lines \ref{alg:sample:norm} and \ref{alg:sample:remove}
in \cref{alg:sample} can be implemented with
a data structure that maintains a subdivision of an interval
into $n$ subintervals and allows lookups and updates.
Walker's alias method seems to be ill-suited for this purpose,
as each item potentially spreads over several "boxes",
which can make updates costly.
A partial sum tree is a data structure similar to a heap
\fxwarning{double-check name, cite Wong and Easton}
that can be initialized in $O(n \log n)$ time and supports
lookup and updates in $O(\log n)$ time.

This paper explores alternative approaches:
rejection sampling and reservoir sampling.
Neither of both approaches fits in the framework of \cref{alg:sample}.
The former uses sampling *with* replacement as a subroutine, and
the latter is based on arithmetic transformation of a probability distribution.


## Rejection sampling

Sampling without replacement can be emulated by sampling with replacement.
In the framework of \cref{alg:sample},
this corresponds to flagging sampled items as "invalid" (instead of removing them)
and repeating the sampling in line \ref{alg:sample:norm}
until a valid item is found.
Here, rejection sampling is used to sample a valid item from a (larger)
set of potentially invalid items.
Note that the distribution of the result is not modified if invalid items
are purged occasionally.

This approach can be implemented by repeatedly calling a subroutine that
returns a sample with replacement, as shown in \cref{alg:sample-rej}.
\fxwarning{Reference?}
The general idea is to sample slightly more items than necessary (with replacement),
and then to throw away the duplicate items.
If the resulting sequence of items is shorter than requested,
the result for a much smaller problem is appended to it.
In \cref{alg:sample-rej},
duplicate items in the result of a sampling with replacement
(line \ref{alg:sample-rej:sample})
correspond to invalid items in the rejection sampling,
and the recursive call in line \ref{alg:sample-rej:rec} corresponds to
purging the invalid items.



\begin{algorithm}
  \caption{$\text{sample.rej}(n, s, p_i)$}
  \label{alg:sample-rej}
  \begin{algorithmic}[1]
    \REQUIRE $n$: Size of the population
    \REQUIRE $s$: Number of items to sample
    \REQUIRE $p_i$: Relative probability of each item for $i \in \{1,\ldots,n\}$
    \ENSURE Returns a vector $k_j \in \{1,\ldots,n\} $ with
      $j \in \{1,\ldots,s\}$ that contains the indexes of the items sampled
    \STATE $k_i \leftarrow \text{unique}(\text{sample}(n, \text{expected.items}(s), \FALSE, p_i))$
      \label{alg:sample-rej:sample}
    \STATE $l \leftarrow \text{length}(k_i)$
    \IF{$l \geq s$}
      \RETURN the first $s$ items of $k_i$
    \ENDIF
    \STATE remove items $k_i$ from $p_i$\label{alg:sample-rej:remove}
    \RETURN $k_i \oplus \text{sample.rej}(n - l, s - l, p_i)$\label{alg:sample-rej:rec}
  \end{algorithmic}
\end{algorithm}

Here, the function expected.items should evaluate to a reasonable estimate
of the number of items that need to be drawn with replacement,
so that the result can be expected to contain at least $s$ unique items.


For $\text{expected.items}(s) \equiv 1$,
\cref{alg:sample,alg:sample-rej} are in fact identical.
A formal proof for the more interesting case $\text{expected.items}(s) > 1$
is beyond the scope of this paper.


# Explanation of the code

# Code

# Examples

# From template

## Code formatting

Don't use markdown, instead use the more precise latex commands:

* \proglang{Java}
* \pkg{plyr}
* \code{print("abc")}

## R code

Can be inserted in regular R markdown blocks.

```{r}
x <- 1:10
x
```
